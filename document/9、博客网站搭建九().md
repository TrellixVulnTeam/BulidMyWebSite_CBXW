9、博客网站搭建九

## 9.1 重置密码
现在用户登录的方式越来越多，指纹，人脸识别，声音，但是呢，密码依然是主要的登录方式，至少目前是的。忘记密码也是很正常的，特别是一些网站你仅仅是看一下就想要你登录，甚至要你手机号，巴拉巴拉一些信息。所以我们现在会有很多账号密码，如果你的所有密码都像我的一样，我的所有密码就两个，所以一般试两下就可以了，但很多人不是的，他们喜欢挑战自己的智商，每个账号一个密码，最后弱智战胜了理智，就有了找回密码。何解？

## 安装第三方库
前面吸怪文章什么的，都是相对比较随意的。但是密码作为用户身份的重要口令。必须以一种更加保险的方式去修改。一般常用的方式是发送一封修改密码的邮件到用户先前绑定的邮箱里。

大概流程如下：

* 向用户邮箱发送包含重置密码地址的邮件，邮件的地址需要动态的生成，防坏人。
* 向网站用户展示一条发送邮件成功的信息。
* 用户点击邮箱中的地址后，转入重置密码的页面。
* 向用户展示；一条重置成功的信息。

Diango内置的木马修改功能就是按照上面的步骤进行的，只要将4步的url配置好就可以了，只是内置模板有点简陋，但是你也可以覆写模板来便成自己的风格。
> 实际上Django不仅内置了密码重置，还包括登录、登出、密码修改等功能。建议读者到一定水平后多阅读Django的源码，学习其中的编程技巧。另外这部分内容Django是用类视图写的，现在阅读可能有一定困难。
> 
> 源码位置：/env/Lib/site-packages/django/contrib/auth/views.py 官方文档：[Django 的验证系统](https://docs.djangoproject.com/zh-hans/2.1/topics/auth/default/)

Django作为优秀的开源框架，有很多第三方库（即APP）被世界各地程序员打包发布到网上，几人已经别人造好了轮子，而且更简单，我们没必要再次建造一个轮子了。

这里有一个第三方库`Django-password-reset`，打开虚拟环境，输入指令：`pip install -U django-password-reset`:

![installreset.png](picture9/installreset.png)

## 快速上手
既然是第三方库也是app，肯定需要在`/myblog/mysite/setting.py`里面注册：

```
import password_reset # 导入

INSTALLED_APPS = [
  ...
  ...
    'password_reset',
]
```
然后进入跟路由`myblog/mysite/urls.py`,添加APP路由：

```
urlpatterns = [
...
...
    path('password-reset', include('password_reset.urls')),
]
```

修改`templates/userprofile/login.html`，提供一个重置密码的入口：

```
...
...
            </form>
            <br>
            <h5>忘记密码？</h5>
            <h5>点击<a href="{% url 'password_reset_recover' %}"> 这里</a>重置密码</h5>
        </div>
...
...
```
邮件不能凭空产生，目前为止欧文还没有配置发送邮件的账号密码，也没有配置发送邮件的端口、发件人信息等。

因此还需要进入`mysite/setting.py`末尾添加发送邮件的相关配置：

```
...
...
# SMTP服务器，改为你邮箱的SMTP
EMAIL_HOST = 'smtp.163.com'
# 改为你自己的邮箱名
EMAIL_HOST_USER = 'wyykissrain@163.com'
# 你的邮箱密码
EMAIL_HOST_PASSWORD = '******'
# 发送邮件的端口
EMAIL_PORT = 25
# 是否使用TLS
EMAIL_USE_TLS = True
# 默认的发件人
DEFAULT_FROM_EMAIL = '寒江雪的博客<wyykissrain@163.com>'

```
> 简单邮件传输协议<Simple Mail Transfer Protocol SMTP>是在Internet传输mail的协议标准。
> 
> SMTP是基于文本的协议，在气质上指定了一条消息或者多个接受者，然后消息文本会被传输，SMTP使用TCP端口25.
> 
> SMTP是一个'推'的协议（发送邮件），它不允许从远程服务器上‘拉’取消息（接受邮件）。要接收邮件，客户端必须使用POP3或者IMAP。

设置好以后，我们开启服务测试：

点击登录页面；
![resetpassword.png](picture9/resetpassword.png)
![sendemail.png](picture9/sendemail.png)


## 9.2 扩展用户信息
Django自带的用户管理基本完善，我们并没有写任何模型，但是Django自带毕竟字段田少，比如手机号、头像等都没有，解决的方法很多，你可以不适用user可以自己重新自定义从零开始，也可以对User模型进行扩展，对于博客网站来说，我们需求不复杂，扩展一下就足够了。

进入`userprofile/models.py`如下：

```
from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save # 引入内置信号
from django.dispatch import receiver # 引入信号接收的装饰器


# 用户扩展信息
class Profile(models.Model):
    # 与User模型构成一对一关联
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    # 电话号码字段
    phone = models.CharField(max_length=20,blank=True,verbose_name='手机号')
    # 头像
    avatar = models.ImageField(upload_to='avatar/%Y%m%d/', blank=True, verbose_name='头像')
    # 个人简介
    bio = models.TextField(max_length=500,blank=True, verbose_name='个人简介')

    def __str__(self):
        return 'user{}'.format(self.user.username)


#  信号接收函数，每当新建User实例时候自动调用
@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)


# 信号接收函数。每当更新user实例时候自动调用
@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    instance.profile.save()

```
> * 每个profile模型对应的唯一一个User模型，形成了对User的外接扩展，因此你可以在Profile添加任何想要的字段。这种方法的好处是不需要对User进行任何的改动，从而拥有自定义的字段，模型本身没有什么新的知识，你叫神器的是用到的信号机制。
> * Django包含一个“信号调度程序”，他可以在框架中的某些位置繁盛操作是，通知其他应用程序，简而言之，信号允许某些发送者通知一组接收器，已经发生了某个动作（和OC语言中的通知机制类似）。但许多代码对同一事件有联系时，信号就特别好用。
> * 这里引入`post_save`就是一个内置的信号，它可以在模型调用`save()`方法后发出信号。
> * 有了信号之后还需要定义而接收器，告诉Django应该把信号发送给谁。装饰器`receiver`就是起到接收器的作用，每当User有跟新的时候，就发送一个信号确定`post_save`相关的函数。
> * 通过信号的传递，实现每当User创建/更新时候，profile也会自动创建更新。
> 
> 当然也可以不使用信号来自动创建profile表，而是采用手动的方式实现。为什么删除User时候不需要信号？答案是两者关系采用了`models.CASCADE`级联删除，已经带有关联的功能了。avatar字段用来存放头像，下面会说。

## 重建数据库
前面说过，每次修改模型后都需要进行数据的迁移。由于`avatar`字段为图像字段，需要安装三方库`Pillow`来支持,`pip install Pillow` 然后进行数据迁移`python manage.py makemigrations`,`python manage.py migrate`如下图：

![pillow.png](picture9/pillow.png)

此时重新登录会出现错误：

![errorprofile.png](picture9/errorprofile.png)

> 这是因为之前创建的User数据没有对应的profile模型，违背了现有的模型，粗暴的解决办法就是直接删除原有旧数据，因此需要用到Django的shell命令。
> 
> Shell是Django提供的互动解释器，可以在这个指令模式中实验代码是否正确执行，是很方便的一个工具。


在虚拟环境输入`python mange.py shell`就可以进入sehll了，然后输入命令删除所有数据：

![deletedata.png](picture9/deletedata.png)

> Attention: 前面写`article`模型中，与User的外键也采用`Model.CASCADE`级联删除模式，因此随着User的删除，相关的文章也一并删除了。
> 
> 输入`exit()`退出shell，输入指令从新创建超级管理员账户：`python manage.py createsuperuser`.
> 
> ***对新手来说，修改数据库经常会导致各种头疼的问题，比如说字段失效、新字段为null、赋值错误、外键链接出错等等，最终导致整个业务逻辑报错。因此我的建议是，在设计数据库时尽量考虑周全，避免频繁修改模型。如果实在要修改，并且已经导致数据库混乱了，不妨删除掉/app/migrations/目录下最新的几个文件，清空相关数据库，重新迁移数据.***

## 表单、视图、模板
有了扩展的Profile模型之后，需要新建一个表单类去编辑它的内容：进入`userprofile/forms.py`:

```
from .models import Profile
...

...
...
# 扩展字段
class ProfileForm(forms.ModelForm):
    class Meta:
        model = Profile
        fields = ('phone', 'avatar', 'bio')

```

然后进入`userprofile/views.py`:
